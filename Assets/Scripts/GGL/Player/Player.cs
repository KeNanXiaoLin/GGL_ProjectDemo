using System;
using System.Collections;
using System.Collections.Generic;
using KNXL.AutoGenerated.Data;
using UnityEngine;

public class Player : MonoBehaviour
{
    [SerializeField] private int crazyValue = 10;
    [SerializeField] private int reasonValue = 10;
    [SerializeField] private float moveSpeed = 1.5f;
    private LineRenderer lineRenderer;
    [SerializeField] private E_InputAction inputAction = E_InputAction.WASD;
    [SerializeField] private float startWidth = 0.05f;
    [SerializeField] private float endWidth = 0.1f;
    private CfgMaskData currentMaskData;
    private E_World currentWorldType => GameManager.Instance.CurrentWorldType;

    private void Awake()
    {
        lineRenderer = GetComponent<LineRenderer>();
        
    }

    private void Start()
    {
        currentMaskData = AbilityManager.Instance.GetAbilityData(10001);
    }

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            ChangeWorld();
        }
        DoInteract();
    }

    private void DoInteract()
    {
        switch (currentWorldType)
        {
            case E_World.In_World:
                // 2.通过鼠标，绘制连线，根据连线的提示判断是否可以附身
                DrawInfoLine();
                // 做附身后的事物独特的内容
                DoSpecialInteractInWorld();
                break;
            case E_World.Out_World:
                DoSpecialInteractOutWorld();
                // 可以进行万向移动
                break;
        }
    }

    /// <summary>
    /// 不同面具在Out_World的特殊交互
    /// </summary>
    private void DoSpecialInteractOutWorld()
    {
        switch (currentMaskData.maskType)
        {
            case E_MaskType.Mouse:
                break;
            case E_MaskType.Cassette:
                
                break;
            default:
                break;
        }
    }
    /// <summary>
    /// 不同面具在In_World的特殊交互
    /// </summary>
    private void DoSpecialInteractInWorld()
    {
        switch (currentMaskData.maskType)
        {
            case E_MaskType.Mouse:
                break;
            case E_MaskType.Cassette:
                
                break;
            default:
                break;
        }
    }

    /// <summary>
    /// 根据鼠标右键的点击绘制线，计算消耗
    /// </summary>
    private void DrawInfoLine()
    {
        if (Input.GetMouseButton(1))
        {
            // 1.直接到物品的位置进行附身
            Vector2 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            lineRenderer.SetPosition(0, transform.position);
            lineRenderer.SetPosition(1, mousePos);
            lineRenderer.startWidth = startWidth;
            lineRenderer.endWidth = endWidth;
            if (GameManager.Instance.mapCell.CalGridDisByWorldPos(transform.position, mousePos) <= 3)
            {
                lineRenderer.startColor = Color.green;
                lineRenderer.endColor = Color.green;
                Cell targetCell = GameManager.Instance.mapCell.WorldToCell(mousePos);
                if(targetCell.HasAbility())
                {
                    lineRenderer.endColor = Color.yellow;
                }
            }
            else
            {
                lineRenderer.startColor = Color.red;
                lineRenderer.endColor = Color.red;
            }
        }
        else if (Input.GetMouseButtonUp(1))
        {
            lineRenderer.startWidth = 0f;
            lineRenderer.endWidth = 0f;
        }
    }

    private void ChangeWorld()
    {
        switch (currentWorldType)
        {
            case E_World.In_World:
                GameManager.Instance.GoToOutWorld();
                Debug.Log("Change to Out_World");
                break;
            case E_World.Out_World:
                GameManager.Instance.GoToInWorld();
                Debug.Log("Change to In_World");
                break;
        }
    }

    private IEnumerator MoveToTarget(List<Vector2> targetPosList)
    {
        foreach (var targetPos in targetPosList)
        {
            Vector2 moveDir = (targetPos - new Vector2(transform.position.x, transform.position.y)).normalized;
            while (Vector2.Distance(transform.position, targetPos) > 0.01f)
            {
                transform.Translate(moveDir * moveSpeed * Time.deltaTime);
                yield return null;
            }
        }
    }
}
